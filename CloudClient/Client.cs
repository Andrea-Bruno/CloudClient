using CloudSync;
using EncryptedMessaging;
using NBitcoin;
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Threading;

namespace CloudClient
{
    /// <summary>
    /// The cloud client objects based on the CloudBox project. Extends the functionality of the CloudBox client
    /// </summary>
    public partial class Client : CloudBox.CloudBox
    {
        public Client(string cloudPath = null, bool isReachable = true) : base(cloudPath, isReachable: isReachable)
        {
            QrCodeDetector.DisallowDetectQrCode = true;
            OnRouterConnectionChangeEvent = OnRouterConnectionChange;
            OnCommandEvent = OnServerCommand;
            OnLocalSyncStatusChangesActionList.Add(OnLocalSyncStatusChanges);

            // EnableOSFeatures(null);
            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows) && !Directory.Exists(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Extra")))
            {
                string zipPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Extra.zip");
                if (File.Exists(zipPath))
                    System.IO.Compression.ZipFile.ExtractToDirectory(zipPath, AppDomain.CurrentDomain.BaseDirectory);
            }
        }



        public void EnableOSFeatures(Action openUI)
        {
            if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
            {
                MacOSSupport.SetOSXStatusIcon(CloudPath, openUI);
            }
        }

        private void OnLocalSyncStatusChanges(Sync.SyncStatus syncStatus, int pendingFiles)
        {
            IconStatus currentStatus;
            if (syncStatus == Sync.SyncStatus.Undefined)
                currentStatus = IconStatus.Default;
            else if (syncStatus == Sync.SyncStatus.Pending)
                currentStatus = IconStatus.Synchronize;
            else if (syncStatus == Sync.SyncStatus.Monitoring)
                currentStatus = IconStatus.Synchronized;
            else
                currentStatus = IconStatus.Warning;
            if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX))
            {
                MacOSSupport.UpdateStatusIcon(currentStatus);
            };
        }
        internal enum IconStatus
        {
            Default,
            Synchronize,
            Synchronized,
            Warning
        }

        /// <summary>
        /// Connect to server and start sync
        /// </summary>
        /// <param name="serverPublicKey">It is the server to which this client must connect (the public key of the server)</param>
        /// <returns>Successful</returns>        
        public void ConnectToServer(string serverPublicKey = null)
        {
            if (EncryptedQR != null)
            {
                // If the login was partially done with an encrypted QR code, once the connection with the router has been established, it asks the cloud for the QR code in order to log in definitively
                SendCommand(EncryptedQR.Item1, Command.GetEncryptedQR, null);
                return;
            }
            serverPublicKey ??= ServerPublicKey; // serverPublicKey = Context.SecureStorage.Values.Get("ServerPublicKey", null);
            SetServerCloudContact(serverPublicKey);
            LoginCredential credential = Pin == null ? null : new LoginCredential { Pin = Pin, PublicKey = Context.My.GetPublicKeyBinary() };
            StartSync(credential);
            return;
        }
        private string ServerPublicKey { get { return Context.SecureStorage.Values.Get(nameof(ServerPublicKey), null); } set { Context.SecureStorage.Values.Set(nameof(ServerPublicKey), value); } }
        private string Pin;

        /// <summary>
        /// Placeholder for a method that will be called when the connection changes  
        /// Function that is called when the connection changes (connected or disconnected)
        /// </summary>
        /// <param name="isConnected">Notify the new connection status</param>
        private void OnRouterConnectionChange(bool isConnected)
        {
            if (Sync == null && isConnected)
                ConnectToServer();
        }

        /// <summary>
        /// Login the Client to the Cloud Server by entry QrCode and Pin of server
        /// </summary>
        /// <param name="qrCode">QR code generated by server cloud, in text format</param>
        /// <param name="pin">Pin</param>
        /// <param name="entryPoint">Router entry point, optional parameter for QR codes that do not contain the entry point</param>
        /// <returns>Validated for Successful, or other result if QR code or PIN is not valid</returns>        
        public LoginResult Login(string qrCode, string pin, string entryPoint = null)
        {
            QrCodeDetector.DisallowDetectQrCode = true;
            var result = TryLogin(qrCode, pin, entryPoint);
            if (result != LoginResult.Successful)
                Logout();
            return result;
        }

        private LoginResult TryLogin(string qrCode, string pin, string entryPoint = null)
        {
            Logout();
            if (string.IsNullOrEmpty(pin))
                return LoginResult.WrongPassword;
            if (SolveQRCode(qrCode, out string entry, out string serverPublicKey, out EncryptedQR) == false) return LoginResult.WrongQR;
            if (entry != null)
                entryPoint = entry;
            var context = CreateContext(entryPoint);
            // =================
            // NOTE: Login is performed when the context has established the connection with the router
            // =================
            Pin = pin; // context.SecureStorage.Values.Set("pin", pin);
            ServerPublicKey = serverPublicKey; // context.SecureStorage.Values.Set("ServerPublicKey", serverPublicKey);
            try
            {
                OnSyncStart = new AutoResetEvent(false);
                if (OnSyncStart.WaitOne(60000))
                {
                    Pin = null;
                    Sync.OnLoginCompleted = new AutoResetEvent(false);
                    if (Sync.OnLoginCompleted.WaitOne(60000))
                        return Sync.LoginError ? LoginResult.WrongPassword : LoginResult.Successful;
                    else if (context.LicenseExpired)
                        return LoginResult.LicenseExpired;
                    else if (Sync == null)
                        return LoginResult.RemoteHostNotReachable;
                    else if (Sync.RemoteHostReachable)
                        return LoginResult.CloudNotResponding;
                    return LoginResult.RemoteHostNotReachable;
                }
                Pin = null;
                return LoginResult.TimeoutError;
            }
            catch (Exception)
            {
                Pin = null;
                return LoginResult.ErrorOccurred;
            }
        }

#pragma warning disable CS1591
        /// <summary>
        /// Result of login validation
        /// </summary>
        public enum LoginResult
        {
            Successful,
            LicenseExpired,
            WrongPassword,
            CloudNotResponding,
            WrongQR,
            RemoteHostNotReachable,
            ErrorOccurred,
            TimeoutError
        }
#pragma warning restore CS1591

        /// <summary>
        /// Close socket connection to the router and stop syncing, stops transmitting with the cloud server, but the connection with the router remains active
        /// </summary>
        /// <returns>False if already logged out, true otherwise</returns>
        public bool Logout()
        {
            QrCodeDetector.DisallowDetectQrCode = false;
            if (File.Exists(FileLastEntryPoint))
                File.Delete(FileLastEntryPoint);
            StopSync();
            if (Context != null)
            {
                Pin = null; // Context.SecureStorage.Values.Set("pin", null);
                ServerPublicKey = null; // Context.SecureStorage.Values.Set("ServerPublicKey", null);
                Context.Dispose();
                Context = null;
                return true;
            }
            return false;
        }

        /// <summary>
        /// Returns true if the cloud is logged in to the server. The returned value is persistent, that is, if the client is logged in it will remain logged in even after a reboot, and this value will return true (after a reboot it is not necessary to log in again)
        /// </summary>
        /// <returns>True if the client is logged in to the server</returns>
        public bool LoginStatus() => File.Exists(FileLastEntryPoint);

        private void SetServerCloudContact(string serverPublicKey)
        {
#if DEBUG || DEBUG_AND
            if (serverPublicKey == null)
            {
                var mnemonic = new Mnemonic(TestServerPassphrase, Wordlist.AutoDetect(TestServerPassphrase));
                var hdRoot = mnemonic.DeriveExtKey();
                var privateKey = hdRoot.PrivateKey;
                serverPublicKey = Convert.ToBase64String(privateKey.PubKey.ToBytes());
            }
#endif
#pragma warning disable
            // ReSharper disable once ConditionIsAlwaysTrueOrFalse
            if (serverPublicKey == null)
                // ReSharper disable once HeuristicUnreachableCode
                serverPublicKey = ServerPublicKey; // serverPublicKey = Context.SecureStorage.Values.Get("ServerPublicKey", null);
            else
                ServerPublicKey = serverPublicKey; // Context.SecureStorage.Values.Set("ServerPublicKey", serverPublicKey);
            // ReSharper disable once ConditionIsAlwaysTrueOrFalse
            if (serverPublicKey != null)
            {
                ServerCloud = Context.Contacts.AddContact(serverPublicKey, "Server cloud", Modality.Server, Contacts.SendMyContact.None);
            }
#pragma warning restore            
        }

        /// <summary>
        /// Execute when Garbage Collector remove it
        /// </summary>
        ~Client()
        {
        }
    }

}
